# 2022-01-02 log

## Spring Security

### 비인증 유저를 위한 페이지 작성 - /auth/** 주소를 가진 페이지들

`/auth` 로 시작하는 주소로 들어오는 페이지들은 인증이 되지 않아도 사용할 수 있는 페이지로 사용하려고 한다. 예를들어 회원가입, 로그인 페이지와 js, css 등과 같은 정적 페이지들은 인증하지 않은 유저들도 사용 가능해야 하므로 `/auth`라는 URI를 이용하여 구분하도록 한다.

### loginForm 변경

 기존에는 JS를 이용하여 AJAX 요청하였지만 Security는 form 태그의 action을 이용하여 사용한다. 그러므로 각 input 태그에 name 값을 넣어 들어오는 데이터의 변수명을 정해준다. 다음은 name에 username, password, remember를 사용하여 폼 요청을 하는 코드이다.

 user.js에서도 login에 대한 코드를 삭제한다.

 ```jsp
 <div class="container">
	<form action="#" method="post">
		<div class="form-group">
			<label for="username">Username :</label>
			<input type="text" name="username" class="form-control" placeholder="Enter username" id="username">
		</div>

		<div class="form-group">
			<label for="pwd">Password :</label>
			<input type="password" name="password" class="form-control" placeholder="Enter password" id="password">
		</div>

		<div class="form-group form-check">
			<label class="form-check-label">
				<input name="remember" class="form-check-input" type="checkbox">
				Remember me
			</label>
		</div>
		<button id="btn-login" class="btn btn-primary">로그인</button>
	</form>
</div>
```

## Security filter Config 설정

### Config 파일 작성 방법

 기본적으로 모든 요청은 Spring Security가 가로채서 확인을 하게 된다. 이 때 위에서 `/auth/**`에 특정 기능을 넣었던 것처럼 설정을 해주려면 filter에 대한 Config가 있어야 하고 시큐리티에 대한 설정을 다음과 같이 하게 된다.

 ```java
// 빈 등록 : 스프링 컨테이너에서 객체를 관리할 수 있게 설정
@Configuration	// 빈등록 (IoC 관리)
@EnableWebSecurity // 시큐리티 필터 추가(Default로 필터됨) -> 필터에 대한 설정을 이 클래스에서 정리함.
@EnableGlobalMethodSecurity(prePostEnabled = true) // 특정 주소로 접근을 하면 권한 및 인증을 미리 체크하겠다는 뜻.
public class SecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.authorizeRequests()					// 다음과 같은 request가 들어오면 호출.
				.antMatchers("/auth/**")		// auth로 시작하는 모든 호출은
				.permitAll()								// 들어오는 것을 허가
				.anyRequest()							// 다른 요청은
				.authenticated();						// 인가 받아야함.
	}
```

### config 파일 override 오류

 configure 자체에 다음과 같은 request.authenticated() 함수가 들어있으므로 ` java.lang.IllegalStateException: Can't configure antMatchers after anyRequest`와 같은 에러를 띄우게 된다.

 이미 정해진 `anyRequest()` 다음에는 uri 호출 조건을 걸 수 없다는 것.

 즉, 조건이 걸린 url을 먼저 설정해주고 마지막에 `anyRequest()`를 인가받던지 다른 기능을 추가해주어야 한다.

```java
	super.configure(http);
```

![image](https://user-images.githubusercontent.com/84966961/147853939-b44042ce-678d-4f2d-ae71-c7f5650d317c.png)

 오류를 찾다보니 [stack overflow](https://stackoverflow.com/questions/60123616/cant-configure-antmatchers-after-anyrequest-multiple-antmatcher)에 다음과 같은 예시가 있길래 참고 사항으로 적어둔다.

 ```java
     http
        .httpBasic()
            .and()
        .authorizeRequests()
            .antMatchers("/rest/**").permitAll()
            .and()
        .authorizeRequests()
            .antMatchers("/secure/**").hasAnyRole("ADMIN")
            .anyRequest().authenticated()
            .and()
        .formLogin()
            .permitAll();
```

### 비인가시 로그인 페이지로 이동 설정

 `/auth/**` 이외에는 페이지 접근이 불가능하므로 유저가 인가할 수 있도록 자동으로 login 페이지로 이동해주도록 설정해주어야 한다.

```java
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		//super.configure(http); // configure에 anyRequest가 있어서 문제 생김.
		http
			.authorizeRequests()					// 다음과 같은 request가 들어오면 호출.
				.antMatchers("/auth/**")		// auth로 시작하는 모든 호출은
				.permitAll()								// 들어오는 것을 허가
				.anyRequest()							// 다른 요청은
				.authenticated()						// 인가 받아야함.
			.and()
				.formLogin()										// 위에서 다른 요청은 인가를 받아야 하므로 
				.loginPage("/auth/loginForm");	// 로그인 페이지로 보냄
	}
```

이렇게 하면 다른 페이지 접속시 자동으로 로그인 페이지로 이동한다.