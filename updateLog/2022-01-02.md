# 2022-01-02 log

## Spring Security Configuration

### 비인증 유저를 위한 페이지 작성 - /auth/** 주소를 가진 페이지들

`/auth` 로 시작하는 주소로 들어오는 페이지들은 인증이 되지 않아도 사용할 수 있는 페이지로 사용하려고 한다. 예를들어 회원가입, 로그인 페이지와 js, css 등과 같은 정적 페이지들은 인증하지 않은 유저들도 사용 가능해야 하므로 `/auth`라는 URI를 이용하여 구분하도록 한다.

### loginForm 변경

 기존에는 JS를 이용하여 AJAX 요청하였지만 Security는 form 태그의 action을 이용하여 사용한다. 그러므로 각 input 태그에 name 값을 넣어 들어오는 데이터의 변수명을 정해준다. 다음은 name에 username, password, remember를 사용하여 폼 요청을 하는 코드이다.

 user.js에서도 login에 대한 코드를 삭제한다.

 ```jsp
 <div class="container">
	<form action="#" method="post">
		<div class="form-group">
			<label for="username">Username :</label>
			<input type="text" name="username" class="form-control" placeholder="Enter username" id="username">
		</div>

		<div class="form-group">
			<label for="pwd">Password :</label>
			<input type="password" name="password" class="form-control" placeholder="Enter password" id="password">
		</div>

		<div class="form-group form-check">
			<label class="form-check-label">
				<input name="remember" class="form-check-input" type="checkbox">
				Remember me
			</label>
		</div>
		<button id="btn-login" class="btn btn-primary">로그인</button>
	</form>
</div>
```

## Security filter Config 설정

### Config 파일 작성 방법

 기본적으로 모든 요청은 Spring Security가 가로채서 확인을 하게 된다. 이 때 위에서 `/auth/**`에 특정 기능을 넣었던 것처럼 설정을 해주려면 filter에 대한 Config가 있어야 하고 시큐리티에 대한 설정을 다음과 같이 하게 된다.

 ```java
// 빈 등록 : 스프링 컨테이너에서 객체를 관리할 수 있게 설정
@Configuration	// 빈등록 (IoC 관리)
@EnableWebSecurity // 시큐리티 필터 추가(Default로 필터됨) -> 필터에 대한 설정을 이 클래스에서 정리함.
@EnableGlobalMethodSecurity(prePostEnabled = true) // 특정 주소로 접근을 하면 권한 및 인증을 미리 체크하겠다는 뜻.
public class SecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.authorizeRequests()					// 다음과 같은 request가 들어오면 호출.
				.antMatchers("/auth/**")		// auth로 시작하는 모든 호출은
				.permitAll()								// 들어오는 것을 허가
				.anyRequest()							// 다른 요청은
				.authenticated();						// 인가 받아야함.
	}
```

### config 파일 override 오류

 configure 자체에 다음과 같은 request.authenticated() 함수가 들어있으므로 ` java.lang.IllegalStateException: Can't configure antMatchers after anyRequest`와 같은 에러를 띄우게 된다.

 이미 정해진 `anyRequest()` 다음에는 uri 호출 조건을 걸 수 없다는 것.

 즉, 조건이 걸린 url을 먼저 설정해주고 마지막에 `anyRequest()`를 인가받던지 다른 기능을 추가해주어야 한다.

```java
	super.configure(http);
```

![image](https://user-images.githubusercontent.com/84966961/147853939-b44042ce-678d-4f2d-ae71-c7f5650d317c.png)

 오류를 찾다보니 [stack overflow](https://stackoverflow.com/questions/60123616/cant-configure-antmatchers-after-anyrequest-multiple-antmatcher)에 다음과 같은 예시가 있길래 참고 사항으로 적어둔다.

 ```java
     http
        .httpBasic()
            .and()
        .authorizeRequests()
            .antMatchers("/rest/**").permitAll()
            .and()
        .authorizeRequests()
            .antMatchers("/secure/**").hasAnyRole("ADMIN")
            .anyRequest().authenticated()
            .and()
        .formLogin()
            .permitAll();
```

### 비인가시 로그인 페이지로 이동 설정

 `/auth/**` 이외에는 페이지 접근이 불가능하므로 유저가 인가할 수 있도록 자동으로 login 페이지로 이동해주도록 설정해주어야 한다.

```java
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		//super.configure(http); // configure에 anyRequest가 있어서 문제 생김.
		http
			.authorizeRequests()					// 다음과 같은 request가 들어오면 호출.
				.antMatchers("/auth/**")		// auth로 시작하는 모든 호출은
				.permitAll()								// 들어오는 것을 허가
				.anyRequest()							// 다른 요청은
				.authenticated()						// 인가 받아야함.
			.and()
				.formLogin()										// 위에서 다른 요청은 인가를 받아야 하므로 
				.loginPage("/auth/loginForm");	// 로그인 페이지로 보냄
	}
```

이렇게 하면 다른 페이지 접속시 자동으로 로그인 페이지로 이동한다.

## 시큐리티 로그인

### 시큐리티가 로그인을 관리하는 방식


우리의 User VO를 못사용하기 때문에 시큐리티의 UserDetails를 사용해야한다. 이 때 우리의 User를 시큐리티의 UserDetails로 변경하기 위한 방법으로 다형성을 이용하여 UserDetails를 extends한 User로 만들어 사용하는 것이다.

또한 시큐리티는 비밀번호 자체로 들어올 경우 로그인이 안되므로 해쉬 암호화를 거쳐 login을 진행 해야한다. 

### 비밀번호 해쉬 함수의 특징

- 어떤 길이의 값이든 고정 길이의 값으로 변경해준다.
- 조금의 값이 변하더라도 완전 다른 해쉬값으로 변하게 된다.

 [해시함수 테스트](http://isweb.joongbu.ac.kr/~zerochobo/crypto.html)

### 회원가입 - 비밀번호 해쉬화

 스프링 시큐리티의 암호화 내부의 인코더인 `BCryptPasswordEncoder` 타입을 사용하여 하게 된다.
 암호화를 원하는 값을 `encode()`함수의 파라미터로 넣어 사용하게 되면 값을 리턴받을 수 있다.

### 암호화 테스트 - JUnit 5 사용

 테스트를 해보기 위해서 JUnit을 라이브러리에 넣어준다음 테스트를 진행하게 된다.

![image](https://user-images.githubusercontent.com/84966961/147855099-8c4c90cd-472c-498d-9e19-41080b0663f6.png)

 라이브러리를 넣어준 후 run as > JUnit test를 해주면 다음의 코드가 실행되는 것을 확인할 수 있다.

![image](https://user-images.githubusercontent.com/84966961/147855125-478a09bc-8b55-469d-9bf7-e6a37ad6eca5.png)

```java
public class EncTest {
	
	@Test
	public void hashTest() {
		String encPassword = new BCryptPasswordEncoder().encode("1234");
		System.out.println("1234 해쉬 : "+encPassword);
	}

}
```

console 화면

![image](https://user-images.githubusercontent.com/84966961/147855136-36a33a5b-e044-4698-afb9-1a1dfbba0f87.png)

### Service 회원가입 수정

 Service 내부에서 Bean설정을 한 `BCryptPasswordEncoder encode`를 통해서 서버에 들어온 User.password 값을 해쉬화 한 후 DB로 넘겼다.

 ```java
 	@Autowired	// SecurityConfig.java 에서 Bean 설정(IoC) 해두었으므로 DI 가능.
	private BCryptPasswordEncoder encoder;
	
	@Transactional
	public int 회원가입(User user) {
		try {
			// 비밀번호 해쉬화
			String rawPassword = user.getPassword();
			String encPassword = encoder.encode(rawPassword);	// 해쉬값
			user.setPassword(encPassword);
			
			// 해쉬화된 비밀번호를 가진 User 객체 저장.
			userRepository.save(user);
			
			return 1;
		} catch (Exception e) {
			e.printStackTrace();
			System.out.println("UserService : 회원가입()" + e.getMessage());
		}
		return -1;
	}
```

### 오류 발생

1. `/js/**` 등과 같은 static 데이터에 접근을 허용해주지 않아서 버튼이 작동하지 않음. 
	- antMatchers() 에 정적 데이터 주소를 넣어줄 수도 있지만 `WebSecurity` 타입을 관리하는 `configure()` 함수를 override 하여 설정하였음. 특정 URL 주소 요청을 무시해줌.
	```java
	@Override
	public void configure(WebSecurity web) throws Exception {
		web.ignoring().antMatchers("/css/**", "/js/**", "/img/**", "/lib/**");
	}
	```

	[ignoring에 대한 자세한 설명](https://ohtaeg.tistory.com/11)

2. 로그인 성공 후 `"/"` 주소로 이동하도록 설정하였으나 막아놔서 이동 불가능.
	- web 혹은 http configure에 `antMatcher`로 설정하여 처리 가능.

3. csrf 토큰 활성화로 인한 접근 불가
	- 테스트를 위하여 비활성화 시킴.
	```java
		@Override
		protected void configure(HttpSecurity http) throws Exception {
		http.csrf().disable() // csrf 토큰 비활성화 (테스트시 비활성화)
					... 생략
	```

### 회원가입 성공

![image](https://user-images.githubusercontent.com/84966961/147855967-9789ae63-19dc-4be1-bb73-85f17f854e5e.png)

db insert 성공(해쉬화된 비밀번호 포함)

![image](https://user-images.githubusercontent.com/84966961/147856268-416800aa-8274-4350-8431-4fd44523d36e.png)

## XSS, csrf

### xss

 `Cross Site Scripting`의 약어로 자바스크립트 공격을 말한다. `<script>`의 for문을 이용하여 서버에 부하를 시킨다던지 악성 스크립트를 다른 사용자에 심어 공격하는 등의 방법으로 스크립트를 이용하여 공격을 한다.

 해결방법은 의외로 간단하다.

 스크립트를 사용하기 위해서는 `<>` 가 필요하므로 **백단**에서 이런 문자들을 받지 않거나 **일반 문자로 치환**하여 이 문제를 해결할 수 있다. 혹은 게시판 등에서 html 태그를 이용한 게시글 등록을 허용해야 한다거나 필요한 기능이 있다면 특정 HTML 태그를 선별하여 **화이트 리스트를 선정** 후, 해당 태그만 사용 가능하도록 만들면 된다.

 이런 공격을 쉽게 해결하기 위해서 네이버에서 만든 `Lucy XSS Filter`라는 오픈 소스 라이브러리가 있다.

 [Lucy XSS Filter](http://naver.github.io/lucy-xss-filter/kr/)
 [Lucy XSS Filter github](https://github.com/naver/lucy-xss-filter)

### csrf

 `Cross site request forgery` 약어로 사이트간 요청 위조를 말한다. 이는 개발자 미처 예상하지 못했거나 혹은 사용자가 자신의 의지와 상관없이 서버를 공격하거나 취약점을 사용하게 되어 공격하는 경우를 말한다. 

 예를들어 `ADMIN`만이 관리할 수 있는 포인트 페이지가 있다고 해보자.

 당연히 개발자는 시큐리티 Config에서 Role로 관리할 수 있는 권한을 정해놨을 것이다.

 하지만 다음과 같이 어떤 유저가 글을 작성하여 `<a href="get방식의 공격 주소"><img src="이미지">` 이미지를 보여주고 관리자가 클릭하게끔 한다면 보안이 뚫리면서 실제로 get방식의 주소 요청을 통해 원치 않는 문제가 발생할 수 있다. 이런 문제를 해결하기 위한 첫번째 방법으로 get방식이 아닌 post 방식으로 처리하게 되면 이와 같은 하이퍼링크 공격은 불가능하게 된다. 하이퍼링크는 오로지 get방식만 가능하기 때문이다.

 다른 방어 방법들은 다음과 같다.

 1. Referrer 체크
	- 요청을 한 페이지의 정보가 저장된 request header의 referrer 속성을 검증하여 차단하는 방법이다. 만약 같은 도메인에서 오는 요청이 아니라면 차단하여 대부분의 공격을 방지할 수 있다.(우리 사이트가 아닌 외부 사이트로부터 오는 요청을 차단하는 것이다.) 물론 비교적 쉽게 Paros, Zap, fiddler 같은 프로그램으로 조작이 간단하다.
 2. CSRF Token 사용
	- 로그인시 사용자의 세션에 특정 토큰을 생성하여 저장해두고 모든 요청에 대하여 이 토큰을 검증하는 방법이다. 당연히 하이퍼링크는 get방식의 요청인데다가 
 3. CAPTCHA 사용
	- 요즘 많이 사용하는 방식. 캡차 이미지 상의 숫자 / 문자가 아니라면 해당 요청을 거부하는 방식이다.

 실제로 form 태그가 아닌 JS를 통해서 AJAX 요청을 했기 때문에 CSRF 토큰이 없어서 스프링 시큐리티가 막아버렸다. 그렇기 때문에 회원가입 테스트가 불가능 했었고, 테스트를 위해서 Config에 `.csrf().disable()`을 걸어 csrf 토큰 체크를 껐다.
