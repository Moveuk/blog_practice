# 2022-01-02 log

## Spring Security Configuration

### 비인증 유저를 위한 페이지 작성 - /auth/** 주소를 가진 페이지들

`/auth` 로 시작하는 주소로 들어오는 페이지들은 인증이 되지 않아도 사용할 수 있는 페이지로 사용하려고 한다. 예를들어 회원가입, 로그인 페이지와 js, css 등과 같은 정적 페이지들은 인증하지 않은 유저들도 사용 가능해야 하므로 `/auth`라는 URI를 이용하여 구분하도록 한다.

### loginForm 변경

 기존에는 JS를 이용하여 AJAX 요청하였지만 Security는 form 태그의 action을 이용하여 사용한다. 그러므로 각 input 태그에 name 값을 넣어 들어오는 데이터의 변수명을 정해준다. 다음은 name에 username, password, remember를 사용하여 폼 요청을 하는 코드이다.

 user.js에서도 login에 대한 코드를 삭제한다.

 ```jsp
 <div class="container">
	<form action="#" method="post">
		<div class="form-group">
			<label for="username">Username :</label>
			<input type="text" name="username" class="form-control" placeholder="Enter username" id="username">
		</div>

		<div class="form-group">
			<label for="pwd">Password :</label>
			<input type="password" name="password" class="form-control" placeholder="Enter password" id="password">
		</div>

		<div class="form-group form-check">
			<label class="form-check-label">
				<input name="remember" class="form-check-input" type="checkbox">
				Remember me
			</label>
		</div>
		<button id="btn-login" class="btn btn-primary">로그인</button>
	</form>
</div>
```

## Security filter Config 설정

### Config 파일 작성 방법

 기본적으로 모든 요청은 Spring Security가 가로채서 확인을 하게 된다. 이 때 위에서 `/auth/**`에 특정 기능을 넣었던 것처럼 설정을 해주려면 filter에 대한 Config가 있어야 하고 시큐리티에 대한 설정을 다음과 같이 하게 된다.

 ```java
// 빈 등록 : 스프링 컨테이너에서 객체를 관리할 수 있게 설정
@Configuration	// 빈등록 (IoC 관리)
@EnableWebSecurity // 시큐리티 필터 추가(Default로 필터됨) -> 필터에 대한 설정을 이 클래스에서 정리함.
@EnableGlobalMethodSecurity(prePostEnabled = true) // 특정 주소로 접근을 하면 권한 및 인증을 미리 체크하겠다는 뜻.
public class SecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.authorizeRequests()					// 다음과 같은 request가 들어오면 호출.
				.antMatchers("/auth/**")		// auth로 시작하는 모든 호출은
				.permitAll()								// 들어오는 것을 허가
				.anyRequest()							// 다른 요청은
				.authenticated();						// 인가 받아야함.
	}
```

### config 파일 override 오류

 configure 자체에 다음과 같은 request.authenticated() 함수가 들어있으므로 ` java.lang.IllegalStateException: Can't configure antMatchers after anyRequest`와 같은 에러를 띄우게 된다.

 이미 정해진 `anyRequest()` 다음에는 uri 호출 조건을 걸 수 없다는 것.

 즉, 조건이 걸린 url을 먼저 설정해주고 마지막에 `anyRequest()`를 인가받던지 다른 기능을 추가해주어야 한다.

```java
	super.configure(http);
```

![image](https://user-images.githubusercontent.com/84966961/147853939-b44042ce-678d-4f2d-ae71-c7f5650d317c.png)

 오류를 찾다보니 [stack overflow](https://stackoverflow.com/questions/60123616/cant-configure-antmatchers-after-anyrequest-multiple-antmatcher)에 다음과 같은 예시가 있길래 참고 사항으로 적어둔다.

 ```java
     http
        .httpBasic()
            .and()
        .authorizeRequests()
            .antMatchers("/rest/**").permitAll()
            .and()
        .authorizeRequests()
            .antMatchers("/secure/**").hasAnyRole("ADMIN")
            .anyRequest().authenticated()
            .and()
        .formLogin()
            .permitAll();
```

### 비인가시 로그인 페이지로 이동 설정

 `/auth/**` 이외에는 페이지 접근이 불가능하므로 유저가 인가할 수 있도록 자동으로 login 페이지로 이동해주도록 설정해주어야 한다.

```java
	@Override
	protected void configure(HttpSecurity http) throws Exception {
		//super.configure(http); // configure에 anyRequest가 있어서 문제 생김.
		http
			.authorizeRequests()					// 다음과 같은 request가 들어오면 호출.
				.antMatchers("/auth/**")		// auth로 시작하는 모든 호출은
				.permitAll()								// 들어오는 것을 허가
				.anyRequest()							// 다른 요청은
				.authenticated()						// 인가 받아야함.
			.and()
				.formLogin()										// 위에서 다른 요청은 인가를 받아야 하므로 
				.loginPage("/auth/loginForm");	// 로그인 페이지로 보냄
	}
```

이렇게 하면 다른 페이지 접속시 자동으로 로그인 페이지로 이동한다.

## 시큐리티 로그인

### 시큐리티가 로그인을 관리하는 방식


우리의 User VO를 못사용하기 때문에 시큐리티의 UserDetails를 사용해야한다. 이 때 우리의 User를 시큐리티의 UserDetails로 변경하기 위한 방법이 두 가지가 있다.

1. 다형성 이용 - UserDetails를 extends한 User로 만들어 사용하는 것.



또한 시큐리티는 비밀번호 자체로 들어올 경우 로그인이 안되므로 해쉬 암호화를 거쳐 login을 진행 해야한다. 

### 비밀번호 해쉬 함수의 특징

- 어떤 길이의 값이든 고정 길이의 값으로 변경해준다.
- 조금의 값이 변하더라도 완전 다른 해쉬값으로 변하게 된다.

 [해시함수 테스트](http://isweb.joongbu.ac.kr/~zerochobo/crypto.html)

### 로그인 - 비밀번호 해쉬화

 스프링 시큐리티의 암호화 내부의 인코더인 `BCryptPasswordEncoder` 타입을 사용하여 하게 된다.
 암호화를 원하는 값을 `encode()`함수의 파라미터로 넣어 사용하게 되면 값을 리턴받을 수 있다.

### 암호화 테스트 - JUnit 5 사용

 테스트를 해보기 위해서 JUnit을 라이브러리에 넣어준다음 테스트를 진행하게 된다.

![image](https://user-images.githubusercontent.com/84966961/147855099-8c4c90cd-472c-498d-9e19-41080b0663f6.png)

 라이브러리를 넣어준 후 run as > JUnit test를 해주면 다음의 코드가 실행되는 것을 확인할 수 있다.

![image](https://user-images.githubusercontent.com/84966961/147855125-478a09bc-8b55-469d-9bf7-e6a37ad6eca5.png)

```java
public class EncTest {
	
	@Test
	public void hashTest() {
		String encPassword = new BCryptPasswordEncoder().encode("1234");
		System.out.println("1234 해쉬 : "+encPassword);
	}

}
```

console 화면

![image](https://user-images.githubusercontent.com/84966961/147855136-36a33a5b-e044-4698-afb9-1a1dfbba0f87.png)

### Service 회원가입 수정

 Service 내부에서 Bean설정을 한 `BCryptPasswordEncoder encode`를 통해서 서버에 들어온 User.password 값을 해쉬화 한 후 DB로 넘겼다.

 ```java
 	@Autowired	// SecurityConfig.java 에서 Bean 설정(IoC) 해두었으므로 DI 가능.
	private BCryptPasswordEncoder encoder;
	
	@Transactional
	public int 회원가입(User user) {
		try {
			// 비밀번호 해쉬화
			String rawPassword = user.getPassword();
			String encPassword = encoder.encode(rawPassword);	// 해쉬값
			user.setPassword(encPassword);
			
			// 해쉬화된 비밀번호를 가진 User 객체 저장.
			userRepository.save(user);
			
			return 1;
		} catch (Exception e) {
			e.printStackTrace();
			System.out.println("UserService : 회원가입()" + e.getMessage());
		}
		return -1;
	}
```

### 오류 발생

1. `/js/**` 등과 같은 static 데이터에 접근을 허용해주지 않아서 버튼이 작동하지 않음. 
	- antMatchers() 에 정적 데이터 주소를 넣어줄 수도 있지만 `WebSecurity` 타입을 관리하는 `configure()` 함수를 override 하여 설정하였음. 특정 URL 주소 요청을 무시해줌.
	```java
	@Override
	public void configure(WebSecurity web) throws Exception {
		web.ignoring().antMatchers("/css/**", "/js/**", "/img/**", "/lib/**");
	}
	```

	[ignoring에 대한 자세한 설명](https://ohtaeg.tistory.com/11)

2. 로그인 성공 후 `"/"` 주소로 이동하도록 설정하였으나 막아놔서 이동 불가능.
	- web 혹은 http configure에 `antMatcher`로 설정하여 처리 가능.

3. csrf 토큰 활성화로 인한 접근 불가
	- 테스트를 위하여 비활성화 시킴.
	```java
		@Override
		protected void configure(HttpSecurity http) throws Exception {
		http.csrf().disable() // csrf 토큰 비활성화 (테스트시 비활성화)
					... 생략
	```

### 회원가입 성공

![image](https://user-images.githubusercontent.com/84966961/147855967-9789ae63-19dc-4be1-bb73-85f17f854e5e.png)

db insert 성공(해쉬화된 비밀번호 포함)

![image](https://user-images.githubusercontent.com/84966961/147856268-416800aa-8274-4350-8431-4fd44523d36e.png)