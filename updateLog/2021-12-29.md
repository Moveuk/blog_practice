# 2021-12-29 log

## 회원 가입 Service 생성 및 db 처리 수행

### Service

 예를 들어 은행 송금 서비스가 있다면 사용자 A가 사용자 B에게 송금을 하는 일이 있을 것이다. 이 때, 송금하는 과정에서 A계좌에서 돈을 빼서 B계좌에 넣는 update과정이 DB에 두 번 일어날 것이다. 이 서비스가 일어날 때 모든 과정의 transaction이 성공을 해야하고 만약 문제가 일어나면 오류 처리를 하거나 재시도를 해서 안정적인 서비스를 제공해야 하므로 유지보수의 편의성과 확장성 및 교체성 효율의 상승을 위하여 한 서비스로 묶어 사용한다.

 ```java
import javax.transaction.Transactional; // javax의 트랜잭셔널을 사용

// 스프링이 컴포넌트 스캔을 통해서 Bean에 등록을 해줌. IoC를 해준다.
@Service
public class UserService {

	@Autowired
	private UserRepository userRepository;
	
	@Transactional
	public int 회원가입(User user) {
		try {
			userRepository.save(user);
			return 1;
		} catch (Exception e) {
			e.printStackTrace();
			System.out.println("UserService : 회원가입()"+e.getMessage());
		}
		return -1;
	}
}
```

 `@Transactional` 어노테이션을 통해서 문제 발생시 자동으로 롤백하도록 해줌.

 ### DTO 완성

 서비스를 DI(Dependency Injection)해서 넣어줌. Role 의 경우에는 수동으로 넣어줌

```java
@RestController // 웹과 앱을 겸용할 수 있음.
public class UserApiController {
	
	@Autowired
	private UserService userService;
	
	@PostMapping("/api/user")
	public ResponseDto<Integer> save(@RequestBody User user) {
		System.out.println("UserApiController : save 호출됨");
		// 실제 DB에 Insert를 위한 로직
		user.setRole(RoleType.USER);	// role 은 없으므로 수동으로 넣어줌
		int result = userService.회원가입(user);
		return new ResponseDto<Integer>(HttpStatus.OK, result); // 1 대신 dto에서 받아와서 넣음.
	}
}
```

### 회원가입 성공

 lombok의 `@Data`가 제대로 작동하지 않아서 getter, setter를 못찾는 경우가 가끔 발생한다.

 회원가입 들어가는 것까지 확인하였다.

 ![image](https://user-images.githubusercontent.com/84966961/147617704-38be4aa9-0332-465d-9a8f-41c655382278.png)


![image](https://user-images.githubusercontent.com/84966961/147617754-65e37e5f-3803-4a99-b9e4-b944355d8b94.png)

현재 비밀번호가 1234 인데 Spring Security는 이런 비밀번호를 거부하므로 해쉬를 이용하여 암호화하여 넣도록 변경하도록 한다.

## ResponseDTO에서의 에러 처리

 지금 현재는 서비스에서 에러가 발생하면 Exception 발생하여 GlobalExceptionHandler로 이동하여 처리된다.(아래 코드 참조)
 
 ```java
 @Service
public class UserService {

	@Autowired
	private UserRepository userRepository;
	
	@Transactional
	public int 회원가입(User user) {
		try {
			userRepository.save(user);
			return 1;
		} catch (Exception e) { // -> 이동
			e.printStackTrace();
			System.out.println("UserService : 회원가입()"+e.getMessage());
		}
		return -1;
	}
}
```

 에러를 ResponseDto을 통해 처리하고 싶으므로 ExceptionHandler를 변경해준다.

 ```java
 @ControllerAdvice // 모든 Exception 이 발생하면 이 클래스로 오도록 설정.
 @RestController
 public class GlobalExceptionHandler {

	// IllegalArgumentException에 대한 예외 처리를 하도록 어노테이션
	@ExceptionHandler(value = IllegalArgumentException.class)
	public ResponseDto<String> handleArgumentException(IllegalArgumentException e) {
		return new ResponseDto<String>(HttpStatus.INTERNAL_SERVER_ERROR.value(), e.getMessage());
	}
```
 
 또한 HttpStatus 값을 상수 명이 아닌 value 값을 받아 오도록 설정해준다.(Dto의 필드 타입을 int로 변경하고 성공 및 에러에 대한 상수 코드에 `.value()`를 붙인다.)