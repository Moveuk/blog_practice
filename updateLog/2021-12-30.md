# 2021-12-30 log

## 스프링의 트랜잭션 처리

### 전통적인 스프링 트랜잭션의 흐름

 1. request 요청(`송금`이라는 요청)
 2. web.xml과 필터를 지나치면서 실행하는 상황
	- `JDBC 커넥션` 시작 : `DB 연결 세션 생성`을 함.
	- 트랜잭션 시작
	- 영속성 컨텍스트 시작(사용자마다 생겨남.)
 3. 스프링 컨테이너 내부에서 요청 분기하는 컨트롤러로 접근함.
 4. 컨테이너가 서비스를 호출하여 db에 접근하여 update를 함.
	- 송금()
	```
		보내는 이의 계좌와 받는이의 계좌를 select함 -> 영속성 컨텍스트에 담김.
	```
 5. 서비스가 영속성 컨텍스트에 존재하는(DB에서는 변경안됨.) 보내는이와 받는이의 정보를 변경하고 다시 컨트롤러로 돌아감.
 6. 컨트롤러는 각 역할에 맞게 `Data(json)`나 `뷰페이지(.html)`를 리턴함.
	- 그 이후 `Response`가 됨.
	- `JDBC 커넥션` 종료 : 마지막으로 DB 연결 세션 종료. 
	- 트랜잭션 종료 : 자동으로 영속성 컨텍스트의 변경된 데이터를 flush하여 DB의 정보를 바꿈. 
	- 영속성 컨텍스트 종료


![image](https://user-images.githubusercontent.com/84966961/147758440-eaf3586a-06e0-434f-a86f-9fb44edfdf7b.png)

 실제로는 DB의 정보를 직접 바꾸는 것이 아니라 `@Transactional`이 달린 메소드 내부에서 DB의 정보를 영속성 컨텍스트로 불러오고 바뀐 객체와 영속성 컨텍스트의 정보가 다른 것을 감지하고 트랜잭션이 끝날 때 JPA가 영속성 컨텍스트 내부의 정보를 DB로 `flush`함으로써 트랜잭션이 마무리 되게 된다.

### 전통적인 스프링 트랜잭션의 문제점과 해결 방안

 전통적인 스프링 트랜잭션의 문제점은 트랜잭션이 열려있는 시간이 길어지면서 db와 변경되는 데이터들간의 간극이 늘어날 수 있는 불안정성이었다. 이런 문제를 해결하기 위해 DB 커넥션과 트랜잭션의 시작과 종료 사이의 시간을 줄이면서 DB의 부하를 줄이도록 하였다.

```
 2번에서(스프링 컨테이너 들어오기 전) 준비되던 JDBC 커넥션과 트랜잭션을 서비스에서 열고 6번에서의 종료 시점을(컨트롤러) 5번(서비스)로 옴겨서 해결하였다.
```

 하지만 이런 해결 방안도 다음과 같은 문제를 불러왔다.

 서비스에서 영속성 컨텍스트를 종료해버려서 만약 컨트롤러에서 영속성 컨테이너의 1차 캐시에서 방금 썼던 데이터도 받아올 수가 없었다. 이런 문제를 해결하기 위해서 영속성 컨텍스트 종료 시점을 컨트롤러 다음으로 옴김으로써 이 문제점을 해결하였다.


 또한, 지연로딩이 일어날 때 다른 문제가 발생했다.

 보통 EAGER 전략일 때는 FK로 묶여있는 데이터(ManyToOne)에 관련된 모든 데이터를 쿼리하여 가져오게 된다. 그 이후 모든 트랜잭션이 끝나게 되면 데이터는 비영속 상태가 된다.

 하지만 Lazy 전략일 때는 지연로딩 하기 때문에 FK에 묶인 데이터를 진짜 db 객체를 가져오는 것이 아닌 복제품인 프록시 객체를 가져오고 서비스에서 사용 후 트랜잭션을 종료하게 된다. 이 때 아직 6 단계(컨트롤러)에서 영속성 컨텍스트가 닫힌 것은 아니므로 영속성 컨텍스트의 객체에는 접근할 수 있게 되고 이 때 DB 커넥션만 열려서 select만 가능하다. 트랜잭션은 열리지 않았으므로 update와 delete는 불가능하기 때문이다. 하지만 여기서 문제점이 발생하는데 컨트롤러에서 데이터를 변경하더라도 트랜잭션이 이미 종료된 상태라 DB로 변경사항들에 대해서 flush가 되지 않는다. 

![image](https://user-images.githubusercontent.com/84966961/147760566-422d4629-4de9-4463-82b5-460cc2f72fe3.png)

 스프링 부트 2.0 부터는 기본적으로 OSIV가 활성화 상태이며 이런 지연 로딩의 프록시 객체에 대한 접근에 대하여 경로를 발행하고 프로덕션 시스템에 영향을 주기 전에 이 문제를 발견 할 수 있다.

 만약 Open Session in View 옵션을 false로 준다면 Persistence Context의 닫히는 시점이 위 사진의 Service로 내려오게 되며 컨트롤러에서는 영속성 컨텍스트에 존재하는 객체에 접근할 수 없다.

 Open Session in View 옵션을 사용함으로써 우리는 Lazy loading을 사용하여 DB의 부하를 줄일 수 있음.

 ### 요점

 전통적인 스프링의 트랜잭션은 request 시점에서 영속성, JDBC 커넥션, 트랜잭션이 함께 열리고 끝나면서 닫혔다.

 이 점이 개선되면서 db의 부하를 줄이는 방향으로 발전했다.
 
 스프링 2.0 부터는 true 상태의 디폴트 값으로 Open in View라는 옵션이 생기며 지연 로딩이 가능하게 되었다.